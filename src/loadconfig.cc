#include "loadconfig.h"
#include "util.h"
#include <assert.h>
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string>
#include <fstream>
#include <iostream>
using namespace std;

int LoadConfig::is_head_file(const char* file) {
    if(strstr(file, ".h") != 0 ||
       strstr(file, ".hh") != 0 ||
       strstr(file, ".hpp") != 0) {
        return 1;
    }
    return 0;
}
/* Note: this we will mainly remove  comments in
   C/C++ code, and this haven't done completely ,
   multi line comments may fall into trouble */
int LoadConfig::get_more_line(fstream& stream, string& res) {
    string line;
    size_t comment = 0;
    size_t begin = 0;
    size_t end = 0;
    size_t no  = string::npos;
    while((getline(stream, line)) != 0) {
        comment = line.find("//");
        begin   = line.find("/*");
        end     = line.find("*/");
        if(comment == no &&
           begin   == no &&
           end     == no) {
            res = line;
            return 1;
        }
        if(comment == 0)
            continue;
        if((comment != no && begin == no) ||
           (comment != no && comment < begin)) {
            res = line.substr(0, comment);
            return 1;
        }

        if(begin != no && end != no) {
            for(size_t k =0; k<line.size(); k++) {
                if(k >= begin && k <= end + 1) continue;
                else res += line[k];
            }
            return 1;
        } else if(begin != no && end == no) { //we need end flag, read more line
            res = line.substr(0, begin);
            while((getline(stream, line)) != 0) {
                if((end = line.find("*/")) != no) {
                    if(end + 2 < line.size()) 
                        res += line.substr(end+2, line.size() - end - 2);
                    break;
                }
            }
        }
    }
    return 0;
}

int LoadConfig::is_main_file(const char* file) {
    assert(file && strlen(file) != 0);
    if(is_head_file(file))
        return 0;
    fstream stream(file);
    string line;
    string str;
    while(get_more_line(stream, line)) {
        if(Have_main_func(line)) {
            return 1;
        }
    }
    return 0;
}

FileType LoadConfig::Get_FileType(const char* name) {
    const char* extensions[] = {".h",".hh", ".hpp",
                                ".c", ".C", ".cc", ".CC",
                                ".cpp", ".CPP", NULL};
    int k = 0;
    const char* p;
    for(k=0; p = extensions[k] , p != NULL; k++) {
        char* pos = strstr(name, p);
        if(pos != 0 && strlen(pos) == strlen(p)) {
            if(k == 0 || k == 1 || k == 2)
                return HEADER;
            if(k == 3 || k == 4)
                return CSRC;
            if(k >= 5 && k <= 8)
                return CCSRC;
        }
    }
    return UNDEF;
}

int LoadConfig::Load_files_iter(const char* path) {
    assert(path && strlen(path) != 0) ;
    struct dirent* ent = 0;
    DIR* pdir = opendir(path);
    struct stat stat_buf;
    FileType type;
    if(pdir == 0) {
        perror("Failed to open dir in loadconfig_init!");
        return 1;
    }

    while((ent = readdir(pdir)) != 0) {
        char all_path[512];
        memset(all_path, 0, sizeof(all_path));
        snprintf(all_path, 512, "%s/%s", path, ent->d_name);
        lstat(all_path, &stat_buf);
        if(S_ISDIR(stat_buf.st_mode)) {
            if(strcmp(ent->d_name, ".") == 0 ||
               strcmp(ent->d_name, "..") == 0 ) {
                continue;
            } else {
                Load_files_iter(all_path);
            }
        }
        else {
            if((type = Get_FileType(ent->d_name)) != UNDEF ) {
                std::string err;
                string res(all_path);
                CanonicalizePath(&res, &err);
                files.push_back(SourceFile(res, type));
            }
        }
    }
    closedir(pdir);
    return 0;
}

string LoadConfig::Get_obj_name(const string& name, string end) {
    size_t pos;
    string res = name;
    pos = name.rfind("/");
    if(pos != string::npos) {
        res = res.substr(pos+1, res.size() - pos - 1);
    }
    pos = res.find(".");
    res = res.substr(0, pos);
    res += end;
    res = "obj/" + res;
    return res;
}

int LoadConfig::Write_config_file() {
    string out = "\n# build.ninja generated by auto config tool in Ninja, \n# modify it according your need, \n";
    out += "# espacially the parameters listed below\n";

    out += "\n # ========== COMPILER ============ # \n";
    out += "C_COMPILER = gcc \n";
    out += "CC_COMPILER = g++ \n";
    out += "FLAGS = -g \n";
    out += "#EXE_LINK_LIB =  \n";
    out += "INCDIR = ./ \n";
    
    out += "\nrule C_RULE \n command = $C_COMPILER $FLAGS -I$INCDIR -MMD -MF $out.d -o $out -c $in\n";
    out += "   description = Building C object $out\n";
    out += "   depfile = $out.d\n";

    out += "\nrule CC_RULE \n command = $CC_COMPILER $FLAGS -I$INCDIR -MMD -MF $out.d -o $out -c $in\n";
    out += "   description = Building CXX object $out\n";
    out += "   depfile = $out.d\n";

    out += "\nrule C_LINK_RULE \n command = $C_COMPILER $FLAGS $EXE_LINK_LIB $in -o $out\n";
    out += "   description = Linking C object $out\n";

    out += "\nrule CC_LINK_RULE \n command = $CC_COMPILER $FLAGS $EXE_LINK_LIB $in -o $out\n";
    out += "   description = Linking CXX object $out\n";

    out += "\nrule AR_RULE\n command = ar cr $out $in \n";
    out += "   description = AR Library $out\n";

    out += "\nrule CLEAN_RULE\n command = rm -rf ./obj/*\n";
        
    out += "\n\n# =========== COMPILER THESE SOURCES ============";
    vector<string> objs;
    for(vector<SourceFile>::iterator iter = files.begin();
        iter != files.end(); ++iter) {
        string obj = Get_obj_name(iter->path, ".o");
        if(iter->type == CSRC) {
            objs.push_back(obj);
            out +=  ( string("\nbuild ") + obj + string(": C_RULE ") + iter->path + "\n");
            out +=  ( string("    DESC = C ") + iter->path);

        }
        else if(iter->type == CCSRC) {
            objs.push_back(obj);
            out += ( string("\nbuild ") + obj + string(" : CC_RULE ") + iter->path + "\n");
            out += ( string("    DESC = CC ") + iter->path);
        }
    }

    bool add_liball = false;
    if(objs.size() > 0) {
        add_liball = true;
        out += "\nbuild obj/liball.a : AR_RULE ";
        string line;
        int newline = 0;
        for(vector<string>::iterator iter = objs.begin(); iter != objs.end(); ++iter) {
            if(line.length() != 0) line += " ";
            line += (*iter);
            if(line.length() > 20) {
                if(newline)
                    line = "                 " + line;
                line += " $\n";
                out += line;
                line = "";
                newline = 1;
            }
        }
        if(newline)
            line = "                 " + line;
        out += line;
    }

    out += "\n\n#############################################\n";
    out += "# The main all target.";

    vector<string> exes;
    string liball_str = add_liball ? "obj/liball.a " : " ";
    for(vector<SourceFile>::iterator iter = files.begin();
        iter != files.end(); ++iter) {
        string exe = Get_obj_name(iter->path, ".exe");
        if(iter->type == CMAIN) {
            exes.push_back(exe);
            out += "\nbuild " + exe + " :  C_LINK_RULE " + liball_str  + iter->path;
        }
        else if(iter->type == CCMAIN) {
            exes.push_back(exe);
            out += "\nbuild " + exe + " : CC_LINK_RULE " + liball_str + iter->path;
        }
    }

    out += string("\nbuild all: phony  ")  + liball_str;
    for(vector<string>::iterator iter = exes.begin(); iter != exes.end(); ++iter) {
        out += " " + *iter + " ";
    }
    out += "\n";
    
    out += "\n#############################################\n";
    out += "# Make the all target the default.\ndefault all\n";

    out += "\nbuild clean: CLEAN_RULE\n";
    std::cout<< out<< std::endl;
    return 0;
}

int LoadConfig::Init_LoadConfig(std::string path) {
    Load_files_iter(path.c_str());
    for(vector<SourceFile>::iterator iter = files.begin();
        iter != files.end(); ++iter) {
        if(is_main_file(iter->path.c_str())) {
            if(iter->type == CSRC)
                iter->type = CMAIN;
            if(iter->type == CCSRC)
                iter->type = CCMAIN;
        }
    }

    Write_config_file();
    return 0;
}

int LoadConfig::Fresh_LoadConfig(std::string path) {
    return 0;
}
